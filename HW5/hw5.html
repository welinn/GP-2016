<!DOCTYPE html>

<html>
<head>
<title>HW5 Steering in 3-space</title>
<style>
body {
  overflow: hidden;
}
#info {
  position: absolute;
  top: 0;
  width: 100%;
}
.button {
  border: none;
  color: white;
  padding: 1% 1%;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 10px 2px;
  cursor: pointer;
  border-radius: 8px;
}
.bomb {
  background-color: white;
  opacity: 0.5;
  color: black; 
  border: 5px solid #008CBA;
}
</style>
</head>

<body>
<div id="info">
  <button class="button bomb">Bomb GO</button>
</div>
<script src='https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js'></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r76/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src='Objects.js'></script>
<script>

var camera, scene, renderer, controls;
var planeLen = 400;

var bomb, halfWidth = 6, bodyLen = 33, headLen = 8;
var bombInitPos = new THREE.Vector3(-planeLen * 0.4, 0, planeLen * 0.4);

var balloon = [];
var buildingHeigh = 100, buildingWidth = 30;
var buildingPos = new THREE.Vector3(planeLen * 0.25, buildingHeigh / 2, -planeLen * 0.375);
var building, buildingPoint = [];

var car;
var clock = new THREE.Clock();
var bombGo = false;
var gc;

$('.bomb').click(function(){
  if(!car.shoot){
    car.shooting();
    scene.add(bomb);
  }
  //bombGo = true;
  //bombGo = !bombGo;
});

init();
animate();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.set(0, 300, 400);
  scene.add(camera);
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  document.body.appendChild(renderer.domElement);
  window.addEventListener('resize', onWindowResize, false);
  
  var gridXZ = new THREE.GridHelper(planeLen / 2, 10);
  gridXZ.setColors(new THREE.Color(0xff0000), new THREE.Color(0xffffff));
  scene.add(gridXZ);

  var light = new THREE.PointLight(0xffffff, 5);
  light.position.set(0, 20, 0);
  scene.add(light);
  
  var blockMaterial = new THREE.MeshBasicMaterial({});
  var total = 9;
  balloon.push(new Block(10, new THREE.Vector3(planeLen * 0.1, 50, -planeLen * 0.25), blockMaterial));
  balloon.push(new Block(10, new THREE.Vector3(planeLen * 0.2, 50, -planeLen * 0.25), blockMaterial));
  balloon.push(new Block(10, new THREE.Vector3(planeLen * 0.3, 50, -planeLen * 0.25), blockMaterial));
  balloon.push(new Block(15, new THREE.Vector3(planeLen * 0.1, 80, -planeLen * 0.25), blockMaterial));
  balloon.push(new Block(15, new THREE.Vector3(planeLen * 0.2, 80, -planeLen * 0.25), blockMaterial));
  balloon.push(new Block(15, new THREE.Vector3(planeLen * 0.3, 80, -planeLen * 0.25), blockMaterial));
  balloon.push(new Block(15, new THREE.Vector3(planeLen * 0.1, 120, -planeLen * 0.25), blockMaterial));
  balloon.push(new Block(15, new THREE.Vector3(planeLen * 0.2, 120, -planeLen * 0.25), blockMaterial));
  balloon.push(new Block(15, new THREE.Vector3(planeLen * 0.3, 120, -planeLen * 0.25), blockMaterial));
  for(var i = 0; i < total; i++)
    scene.add(balloon[i].mesh);
	
  
  bomb = new Bomb(
    halfWidth, bodyLen, headLen,
    bombInitPos
  );
  var target_building = buildingPos.clone();
  target_building.y = buildingHeigh;
  bomb.init(target_building);
//  scene.add(bomb);
  
  car = new Car(bomb, halfWidth, bodyLen);
  scene.add(car);
  
  building = new THREE.Mesh(
    new THREE.BoxGeometry(buildingWidth, buildingHeigh, buildingWidth),
    new THREE.MeshNormalMaterial());
  building.position.copy(buildingPos);
  scene.add(building);
  createBuildingPoint();
  
  var gui = new dat.GUI();
  initGc();
//  gui.remember(gc);
  var bombControl = gui.addFolder('BombControl');
  bombControl.open();
  var pitch = bombControl.add(gc, 'Pitch', 0, Math.PI * 0.5);
  var yaw = bombControl.add(gc, 'Yaw', -Math.PI * 0.5, Math.PI * 0.5);
  pitch.onChange(function(value) {
    car.rotation.x = -value;
  });
  yaw.onChange(function(value) {
    car.rotation.z = -value;
  });
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function createBuildingPoint(){
  var halfH = buildingHeigh * 0.5;
  var helfW = buildingWidth * 0.5;
  var x = buildingPos.x, y = buildingPos.y, z = buildingPos.z;
  buildingPoint.push(x - helfW);
  buildingPoint.push(x + helfW);
  buildingPoint.push(y - halfH);
  buildingPoint.push(y + halfH);
  buildingPoint.push(z - helfW);
  buildingPoint.push(z + helfW);
}

function initGc(){
  gc = {
    Pitch: 0.9,
    Yaw: 0.5,
  }
  car.rotation.x = -0.9;
  car.rotation.z = -0.5;
}

function collisionCheck(bombHead, points, balloon){
  if(bombHead.x >= points[0] && bombHead.x <= points[1] &&
     bombHead.y >= points[2] && bombHead.y <= points[3] &&
     bombHead.z >= points[4] && bombHead.z <= points[5]){
    scene.remove(building);
    return true;
  }
  for(var i = 0; i < balloon.length; i++){
    if(balloon[i].pos.clone().sub(bombHead).length() < balloon[i].r){
      scene.remove(balloon[i].mesh);
      return true;
    }
  }
  return false;
}

function animate() {
  if(car.shoot){
    var dt = clock.getDelta();
    var collision;
	
    bomb.checkNearBlock(balloon);
    bomb.update(dt, buildingHeigh * 2);
	var headPos = bomb.localToWorld(new THREE.Vector3(0, bomb.bodyLen, 0));
    collision = collisionCheck(headPos, buildingPoint, balloon);

    if(bomb.position.clone().sub(bomb.target).length() < 100) bomb.target.y = 0;
    if(collision){
      scene.remove(bomb);
      car.shoot = false;
    }
  }
  controls.update();
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
</script>
</body>
</html>